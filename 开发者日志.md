这里放一些没什么用的东西。

### 修改记录

- 2023/3/12：添加了项目大纲，但还是用 socket 实现的。

- 2023/3/13：添加了本项目，并准备使用 rpc 实现。
  
  - 实现了 登录 模块的 server 端 和 client 端 并测试成功。
  
  - 实现了 移动 模块，但在输入上出现了问题。

- 2023/3/14：
  
  - 完成了 基于 rpc 的项目框架
  
  - 实现了移动和通讯的功能，测试成功
  
  - 完善了登录的相关功能

- 2023/3/15：
  
  - 添加了 To do list

### To do list

- 编写文档

- 回答问题

- 服务端保存数据到文件里

- 改一下输入，服务端输入多个用户数据

- 更改客户端界面，找 `Go` 的键盘监听函数 和 清屏函数

### 项目大纲

这还是之前的

初始化并登录

- 服务端读取 玩家的 `name` 和 `passwd` 的 md5 和 地图，开始监听。

- 客户端发送 md5 加密后的 `name | passwd`

- 服务器接受 用 加密后的 用户名 和 密码：返回 `Accept` 或 `Wrong`

- 客户端根据返回值决定是否退出循环。

游戏过程

- 数据包类
  
  `操作序号id | 移动指令WASD O 或 修改指令FC | 坐标(x,y) | 地图{{...}...{...}}`
  
  - 修改指令 `F` 表示无论操作序号是否符合都修改。
  
  - `U` 则表示操作序号相同时才修改。

- 客户端
  
  - 线程一：
    
    - `Lock`
    
    - 接受玩家 WASD 指令。
    
    - 计算地图发送
    
    - 操作序号+移动指令+（该序号移动完）移动后的坐标+移动后的地图到 服务端
      
      `112 W (1,2) {{...}...{...}}`
    
    - 重新打印页面
    
    - `Unlock`
  
  - 线程二：接受 修正 数据包
    
    - 收到数据包
    
    - `Lock`
    
    - 根据 操作序号 和 操作命令 修改
    
    - `Unlock`
  
  - 线程三：每隔 0.05 秒发送一包数据（本来打算在服务器上干这事）
    
    - `Lock`
    
    - `122 D (x,y) {{...}...}`
    
    - `Unlock`

- 服务端
  
  - 线程一：生产者
    
    - 接受 客户端 线程一 发送的数据包。
    
    - `Lock`
    
    - 放入队列
    
    - `Unlock`
  
  - 线程二： 消费者
    
    - `Lock`
    
    - 取出队首
    
    - 根据服务器的地图验算
      
      - 先验算序号，若不符合直接修正，否则对比或验算。
      
      - 若相符合，结束。
      
      - 若不符合，发送一份修正数据包到 客户端（由客户端线程 2 接收），强制修改。
        
        `122 F (x,y) {{...}...{...}}` 操作序号+Force+移动后的坐标+移动后的地图。
    
    - `Unlock`

退出

- 还没想好
